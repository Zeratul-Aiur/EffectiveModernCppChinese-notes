# 类型推导

- 类型推导的广泛应用，让人从拼写那些或明显或冗杂的类型名中脱离出来。但是类型推导也会让代码更复杂，因为由编译器进行的类型推导并不总是如程序员所期望的那样进行。

## 条款一：理解模板类型推导

```cpp
template <typename T>
void f(ParamType param);

f(expr);
```

- 注意`T`类型不仅依赖`expr`，还依赖于`ParamType`的形式。
- 例如当`expr`为数组和函数，`ParamType`为值类型，即`T`时，最终结果会分别退化成指针和函数指针。

## 条款二：理解 auto 类型推导

- `auto`的类型推导基本等同于模板推导。除了**初始化列表**的情形，这种情况下类型推导会失败。

### 使用 auto 的好处

- 对于一些冗长的类型可以减少代码。
- 避免出现显示类型不当导致的代码问题。

  ```cpp
  std::map<std::string, int> m;
  for(const std::pair<std::string, int>& p: m) {...}
  for(const auto& p: m) {...}
  ```

  - `std::map`的键实际是不可修改的，因此实际类型是`std::pair<const std::string, int>`，如果如上述显示声明类型，编译器会把所有的对象都拷贝一遍。

## 条款三：理解 decltype

- `decltype`总是不加修改的产生变量或者表达式的类型。
- 主要用于声明函数模板，用于返回值类型后置。

## 条款四：学会查看类型推导结果

- 编辑代码的时候可以依靠 IDE 编辑器获取类型推导结果。
- 关注编译器出错时的错误信息，这些信息无形地提到了造成我们编译错误的类型是什么。
